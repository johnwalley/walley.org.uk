import { ArticleLayout } from '@/components/ArticleLayout'

export const meta = {
  author: 'John Walley',
  date: '2025-10-03',
  title: 'TypeScript monorepos without the drama (pnpm + Vite)',
  description: "How to structure packages, wire up tooling, and ship clean artifacts.",
}

export default (props) => <ArticleLayout meta={meta} {...props} />

## TL;DR

- __Workspaces__ link packages locally and give you one dependency graph. They don't build or type-check anything by themselves.
- __Three axes to decide up front__:
  1. __Local-only__ vs __published__ packages (what's purely internal vs what goes to a registry)
  1. __Direct-export (`src/`)__ vs __pre-built (`dist/`)__ libraries
  1. __Tooling__: Vite for apps, Rollup/Vite library mode for libs
- For the fastest inner loop: __local-only__ + __direct-export__ + __Vite__
- For anything published: __separate build__ + __type declarations__

## Axis 1 - Local-only vs published packages

If we further distinguish between __internally published__ and __externally published__ packages then we can describe three types:

- __local only__ - not published, may, or may not, have a build step.
- __internally published__ - published to an internal registry, may, or may not, have a build step
- __externally published__ - published to a public registry; always have a build step

References: [vite-ts-monorepo-rfc](https://github.com/vitejs/vite-ts-monorepo-rfc/blob/main/RFC-v1.md#package-types), [Turborepo](https://turborepo.com/docs/core-concepts/internal-packages#just-in-time-packages)

## Axis 2 - Direct-export vs pre-built

Two ways to make a library consumable:

### Direct-export (`src/`)

Point your `exports` at the TypeScript source so it can be compiled on the fly.

```json
// package.json
{
  "name": "@acme/lib-a",
  "exports": { ".": "./src/index.ts" },
  "types": "./src/index.ts"
}
```

__When to use__: local-only libs, or other internal repositories you control

__Trade-offs__: consumers must have a TypeScript pipeline; no single compiled artifact; slower cold builds in big apps.

### Pre-built (`dist/`)

Run a build first and export compiled output + declarations.

```json
// package.json
{
  "name": "@acme/lib-b",
  "type": "module",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    }
  },
  "types": "./dist/index.d.ts"
}
```

__When to use__: anything published externally.

__Hybrid__: conditional exports for DX in dev, stable `dist/` in prod:

```json
// package.json (hybrid)
{
  "exports": {
    ".": { "development": "./src/index.ts", "default": "./dist/index.js" }
  },
  "types": "./dist/index.d.ts"
}
```

And in the appâ€™s Vite config:

```json
// vite.config.ts
import { defineConfig } from 'vite';

export default defineConfig(({ mode }) => ({
  resolve: { conditions: mode === 'development' ? ['development'] : [] }
}));
```

## Axis 3 - Tooling: where Vite and Rollup fit

- __Vite__ is your app dev server + production bundler (Rollup under the hood). It transpiles TypeScript with esbuild, __does not type-check__.
- __Library bundlers__: Rollup/Vite library mode to emit ESM/CJS plus `.d.ts` (via plugin).

__Baseline that works__:

- Apps: Vite for dev/build.
- Libraries: Build JavaScript with Vite/Rollup. Emit types with `vite-plugin-dts`.

## Publishing clean artifacts with pnpm

Bundle internal libraries and create a clean `package.json` without the bundled dependencies.

## Example repository

[GitHub](https://github.com/johnwalley/managing-typescript-packages-in-monorepos)

References: [Managing TypeScript Packages in Monorepos](https://nx.dev/blog/managing-ts-packages-in-monorepos)
